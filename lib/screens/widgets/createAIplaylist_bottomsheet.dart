import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:vibey/Repo/CrossAPI/cross_api.dart';
import 'package:vibey/models/songModel.dart';
import 'package:vibey/screens/widgets/snackbar.dart';
import 'package:vibey/services/db/cubit/DBCubit.dart';
import 'package:vibey/services/db/db_service.dart';
import 'package:vibey/theme/default.dart';
import 'package:http/http.dart' as http;
import 'package:flutter_dotenv/flutter_dotenv.dart';
import 'dart:convert';

import 'package:vibey/utils/importer.dart';

class AIPlaylistGenerator {
  static Future<List<String>> fetchSongsFromAI(String prompt) async {
    final apiKey = dotenv.env['API_KEY'];
    final baseUrl = dotenv.env['Base_URL'];
    if (apiKey == null) {
      throw Exception('AI API key not found.');
    }

    try {
      final response = await http.post(
        Uri.parse("$baseUrl"),
        headers: {
          "Authorization": "Bearer $apiKey",
          "Content-Type": "application/json",
        },
        body: json.encode({
          "model": "meta-llama/Llama-Vision-Free",
          "messages": [
            {
              "role": "system",
              "content":
                  "Generate a playlist of 10-15 song names based on the given prompt. Return only song names, one per line, with artist names.",
            },
            {"role": "user", "content": prompt},
          ],
          "max_tokens": 300,
          "temperature": 0.5,
        }),
      );

      if (response.statusCode == 200) {
        final data = json.decode(response.body);
        final content = data["choices"][0]["message"]["content"] as String;
        return content
            .split("\n")
            .where((line) => line.trim().isNotEmpty)
            .toList();
      } else {
        throw Exception("Failed to fetch songs from AI: ${response.body}");
      }
    } catch (e) {
      rethrow;
    }
  }

  static Stream<ImporterState> fetchAndCreatePlaylistFromAI(
    String prompt,
    BuildContext context,
  ) async* {
    SnackbarService.showMessage("Generating AI playlist in background...");

    yield ImporterState(
      totalItems: 0,
      importedItems: 0,
      failedItems: 0,
      isDone: false,
      isFailed: false,
      message: "Generating AI playlist...",
    );

    try {
      final songs = await fetchSongsFromAI(prompt);

      if (songs.isEmpty) {
        yield ImporterState(
          totalItems: 0,
          importedItems: 0,
          failedItems: 0,
          isDone: false,
          isFailed: true,
          message: "No songs generated for '$prompt'.",
        );
        return;
      }

      final playlistName = "AI Playlist - $prompt";
      DBService.createPlaylist(
        playlistName,
        source: 'deepseek',
        description: 'Generated by AI',
        isAlbum: false,
        permaURL: '',
        artURL: '',
      );

      int totalItems = songs.length;
      int importedItems = 0;
      int failedItems = 0;

      for (var song in songs) {
        try {
          MediaItemModel? mediaItem = await CrossAPI().getYtTrackByMeta(
            song.trim(),
            useStringMatcher: false,
          );

          if (mediaItem != null) {
            DBService.addMediaItem(
              MediaItem2MediaItemDB(mediaItem),
              playlistName,
            );
            importedItems++;
          } else {
            failedItems++;
          }

          yield ImporterState(
            totalItems: totalItems,
            importedItems: importedItems,
            failedItems: failedItems,
            isDone: false,
            isFailed: false,
            message: "Importing($importedItems/$totalItems): $song",
          );
        } catch (e) {
          failedItems++;
        }
      }

      final successMessage =
          importedItems > 0
              ? "Playlist '$playlistName' created successfully!"
              : "No songs could be imported for '$playlistName'";

      yield ImporterState(
        totalItems: totalItems,
        importedItems: importedItems,
        failedItems: failedItems,
        isDone: true,
        isFailed: importedItems == 0,
        message: successMessage,
      );

      SnackbarService.showMessage(successMessage);
    } catch (e) {
      SnackbarService.showMessage(
        "Failed to generate playlist. Try again later.",
      );
    }
  }

  static void showAIPromptDialog(BuildContext context) {
    final TextEditingController _promptController = TextEditingController();
    showDialog(
      context: context,
      builder:
          (context) => AlertDialog(
            title: Text("Generate your AI playlist"),
            content: TextField(
              controller: _promptController,
              decoration: InputDecoration(
                hintText: "e.g., Chill Lo-fi Beats for Study",
                border: OutlineInputBorder(),
                focusedBorder: OutlineInputBorder(
                  borderSide: BorderSide(color: Default_Theme.accentColor1),
                ),
                enabledBorder: OutlineInputBorder(
                  borderSide: BorderSide(color: Default_Theme.accentColor1),
                ),
              ),

              maxLines: 3,
            ),
            actions: [
              TextButton(
                onPressed: () => Navigator.pop(context),
                child: Text("Cancel"),
              ),
              ElevatedButton(
                style: ElevatedButton.styleFrom(
                  backgroundColor: Default_Theme.accentColor1,
                ),
                onPressed: () {
                  final prompt = _promptController.text.trim();
                  if (prompt.isNotEmpty) {
                    Navigator.pop(context);
                    // Use BlocProvider to dispatch the playlist generation
                    context.read<DBCubit>().generateAIPlaylist(prompt, context);
                  } else {
                    SnackbarService.showMessage(
                      "Please enter a playlist description",
                    );
                  }
                },
                child: Text("Generate", style: TextStyle(color: Colors.white)),
              ),
            ],
          ),
    );
  }
}

extension AIPlaylistExtension on DBCubit {
  void generateAIPlaylist(String prompt, BuildContext context) {
    Stream<ImporterState> playlistStream =
        AIPlaylistGenerator.fetchAndCreatePlaylistFromAI(prompt, context);

    playlistStream.listen(
      (state) {
        if (state.isDone) {
          // You might want to trigger a refresh or reload of the media database
          emit(MediadbInitial()); // Reset to initial state or trigger a reload
        } else if (state.isFailed) {
          // If you have an error state, you could create one
          emit(MediadbError(state.message));
        }
      },
      onError: (error) {
        emit(MediadbError('Failed to generate playlist: $error'));
      },
    );
  }
}
